import "{{ 'embla-carousel.umd.js' | asset_url }}"
import "{{ 'embla-carousel-autoplay.umd.js' | asset_url }}"
import "{{ 'embla-carousel-auto-scroll.umd.js' | asset_url }}"
import "{{ 'embla-carousel-auto-height.umd.js' | asset_url }}"
import "{{ 'embla-carousel-class-names.umd.js' | asset_url }}"
import "{{ 'embla-carousel-fade.umd.js' | asset_url }}"
import "{{ 'embla-carousel-wheel-gestures.umd.js' | asset_url }}"

const EMBLA_SLIDE_NAME = 'embla-slide'
const EMBLA_CONTAINER_NAME = 'embla-slides'
const EMBLA_NEXT_NAME = 'embla-next'
const EMBLA_PREV_NAME = 'embla-prev'
const EMBLA_SLIDER_NAME = 'embla-slider'
const EMBLA_PROGRESS_NAME = 'embla-progress'
const EMBLA_THUMBNAIL_NAME = 'embla-thumbnail'

const camelize = s => s.replace(/-./g, x=>x[1].toUpperCase())

customElements.define(EMBLA_SLIDE_NAME, class extends HTMLElement{});
customElements.define(EMBLA_CONTAINER_NAME, class extends HTMLElement{});
class EmblaThumbnail extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api.scrollTo(this.index)
    })
  }
  static get observedAttributes() {
    return ["for", "index"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_THUMBNAIL_NAME, EmblaThumbnail);
class EmblaNext extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api?.scrollNext()
    })
  }
  disable(){
    this.setAttribute("disabled", true)
  }
  enable(){
    this.removeAttribute("disabled")
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_NEXT_NAME, EmblaNext);
class EmblaPrev extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api?.scrollPrev()
    })
  }
  disable(){
    this.setAttribute("disabled", true)
  }
  enable(){
    this.removeAttribute("disabled")
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_PREV_NAME, EmblaPrev);
class EmblaProgress extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    
  }
  update(){
    const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
    const progress = Math.max(0, Math.min(1, slider.api?.scrollProgress() ?? 0))
    this.style.setProperty('--progress', `${progress * 100}%`);
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_PROGRESS_NAME, EmblaProgress);
class EmblaSlider extends HTMLElement {
  static BREAKPOINT_SMALL  = '(max-width: {{settings.breakpoint_small}}px)'
  static BREAKPOINT_MEDIUM = '(max-width: {{settings.breakpoint_medium}}px)'
  static OPTIONS_PROPERTIES = ["options", "options-medium", "options-small"]

  constructor() {
    super();
  }
  connectedCallback() {
    this.plugins = [
      // EmblaCarouselAutoplay({ playOnInit: false, delay: 3000 }),
      // EmblaCarouselAutoScroll({ playOnInit: false }),
      EmblaCarouselAutoHeight(),
      // EmblaCarouselFade(),
      EmblaCarouselClassNames(),
    ]
    const options = { 
      ...this.options,
      // container: this.querySelector(EMBLA_CONTAINER_NAME),
      breakpoints:{
        [EmblaSlider.BREAKPOINT_MEDIUM]: { 
          ...this.optionsMedium
        },
        [EmblaSlider.BREAKPOINT_SMALL]: { 
          ...this.optionsSmall
        },
      },
    }
    this.api = EmblaCarousel(this, options, this.plugins)

    this.api.on('slideschanged', () => {

    })
    this.api.on('select', () => {
      this.updateControls()
    })
    this.api.on('init', () => {
      this.updateControls()
      this.updateProgress()
    })
    this.api.on('reInit', () => {
      this.updateControls()
      this.updateProgress()
    })
    this.api.on('scroll', () => {
      this.updateProgress()
    })
    this.api.on('slideFocus', () => {
      this.updateProgress()
    })
    this.api.on('destroy', () => {})
  }
  updateControls(){
    const nexts = [...document.querySelectorAll(`${EMBLA_NEXT_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_NEXT_NAME}`)]
    nexts.forEach(n => this.api.canScrollNext() ? n.enable() : n.disable())
    const prevs = [...document.querySelectorAll(`${EMBLA_PREV_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_PREV_NAME}`)]
    prevs.forEach(n => this.api.canScrollPrev() ? n.enable() : n.disable())
  }
  updateProgress(){
    const progress = [...document.querySelectorAll(`${EMBLA_PROGRESS_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_PROGRESS_NAME}`)]
    progress.forEach(n => n.update())
  }
  static get observedAttributes() {
    return ["id", ...EmblaSlider.OPTIONS_PROPERTIES];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    const jsProperty = camelize(property)
    if (EmblaSlider.OPTIONS_PROPERTIES.includes(property)){
      // parse string before assignment
      this[ jsProperty ] = Object.fromEntries(newValue.split(',').map(option => {
        const [key, value] = option.split(':')
        if(value.match(/true|false/g)){ // is boolean value
          return [key.trim(), value.trim() == "true"]
        }
        if(value.match(/[0-9]+/g)){ // is number
          return [key.trim(), Number(value.trim())]
        }
        return [key.trim(), value.trim()]
      }));
      console.log(jsProperty, this[ jsProperty ])
      return;
    }
    this[ jsProperty ] = newValue;
  }

}
customElements.define(EMBLA_SLIDER_NAME, EmblaSlider);