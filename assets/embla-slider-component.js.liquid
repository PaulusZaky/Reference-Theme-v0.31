import "{{ 'embla-carousel.umd.js' | asset_url }}"
import "{{ 'embla-carousel-autoplay.umd.js' | asset_url }}"
import "{{ 'embla-carousel-auto-scroll.umd.js' | asset_url }}"
import "{{ 'embla-carousel-auto-height.umd.js' | asset_url }}"
import "{{ 'embla-carousel-class-names.umd.js' | asset_url }}"
import "{{ 'embla-carousel-fade.umd.js' | asset_url }}"
import "{{ 'embla-carousel-wheel-gestures.umd.js' | asset_url }}"

const EMBLA_SLIDE_NAME = 'embla-slide'
const EMBLA_CONTAINER_NAME = 'embla-container'
const EMBLA_NEXT_NAME = 'embla-next'
const EMBLA_PREV_NAME = 'embla-prev'
const EMBLA_SLIDER_NAME = 'embla-slider'
const EMBLA_PROGRESS_NAME = 'embla-progress'
const EMBLA_THUMBNAIL_NAME = 'embla-thumbnail'

customElements.define(EMBLA_SLIDE_NAME, class extends HTMLElement{});
customElements.define(EMBLA_CONTAINER_NAME, class extends HTMLElement{});
class EmblaThumbnail extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.index = Number(this.getAttribute("index"))
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api?.scrolTo(Number(this.index))
    })
  }
  static get observedAttributes() {
    return ["for", "index"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_THUMBNAIL_NAME, EmblaThumbnail);
class EmblaNext extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api?.scrollNext()
    })
  }
  disable(){
    this.setAttribute("disabled", true)
  }
  enable(){
    this.removeAttribute("disabled")
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_NEXT_NAME, EmblaNext);
class EmblaPrev extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    this.addEventListener('click', () => {
        const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
        slider.api?.scrollPrev()
    })
  }
  disable(){
    this.setAttribute("disabled", true)
  }
  enable(){
    this.removeAttribute("disabled")
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_PREV_NAME, EmblaPrev);
class EmblaProgress extends HTMLElement{
  constructor() {
    super();
  }
  connectedCallback() {
    
  }
  update(){
    const slider = this.closest(EMBLA_SLIDER_NAME) || document.getElementById(this.for)
    const progress = Math.max(0, Math.min(1, slider.api?.scrollProgress() ?? 0))
    this.style.setProperty('--progress', `${progress * 100}%`);
  }
  static get observedAttributes() {
    return ["for"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_PROGRESS_NAME, EmblaProgress);
class EmblaSlider extends HTMLElement {
  constructor() {
    super();
  }
  connectedCallback() {
    this.plugins = [
      // EmblaCarouselAutoplay({ playOnInit: false, delay: 3000 }),
      // EmblaCarouselAutoScroll({ playOnInit: false }),
      EmblaCarouselAutoHeight(),
      // EmblaCarouselFade(),
      EmblaCarouselClassNames(),
    ]
    this.options = { loop: false }
    this.api = EmblaCarousel(this, this.options, this.plugins)

    this.api.on('slideschanged', () => {

    })
    this.api.on('select', () => {
      this.updateControls()
    })
    this.api.on('init', () => {
      this.updateControls()
      this.updateProgress()
    })
    this.api.on('reInit', () => {
      this.updateControls()
      this.updateProgress()
    })
    this.api.on('scroll', () => {
      this.updateProgress()
    })
    this.api.on('slideFocus', () => {
      this.updateProgress()
    })
    this.api.on('destroy', () => {})
  }
  updateControls(){
    const nexts = [...document.querySelectorAll(`${EMBLA_NEXT_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_NEXT_NAME}`)]
    nexts.forEach(n => this.api.canScrollNext() ? n.enable() : n.disable())
    const prevs = [...document.querySelectorAll(`${EMBLA_PREV_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_PREV_NAME}`)]
    prevs.forEach(n => this.api.canScrollPrev() ? n.enable() : n.disable())
  }
  updateProgress(){
    const progress = [...document.querySelectorAll(`${EMBLA_PROGRESS_NAME}[for="${this.id}"]`), ...this.querySelectorAll(`${EMBLA_PROGRESS_NAME}`)]
    progress.forEach(n => n.update())
  }
  static get observedAttributes() {
    return ["id"];
  }
  attributeChangedCallback(property, oldValue, newValue) {
    if (oldValue === newValue) return;
    this[ property ] = newValue;
  }
}
customElements.define(EMBLA_SLIDER_NAME, EmblaSlider);